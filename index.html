<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="x-ua-compatible" content="ie=9" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RSS Viewer</title>
  <link rel="icon" type="image/x-icon" href="/RssViewer/RssViewer.ico">
  <!-- <link rel="stylesheet" href="RssViewer.css"> -->
  <link rel="stylesheet" href="RssViewerDark.css">
</head>
<body>
  <div id="app">
    <header id="feed-header">
      <h1 id="feed-title"><a id="feed-link" target="_blank">RSS Viewer</a></h1>
      <div class="small" id="feed-info"></div>
    </header>

    <!-- Template for each feed entry -->
    <template id="entry-template">
      <article class="entry">
        <h2 class="entry-title"><a class="entry-link" target="_blank"></a></h2>
        <div class="entry-meta"><time class="entry-date"></time></div>
        <div class="entry-content"></div>
      </article>
    </template>

    <template id="media-template">
        <div class="media-div">
            <img class="media-image"></img>
            <p class="media-content"></p>
        </div>
    </template>

    <div id="entries" aria-live="polite"></div>
  </div>

  <!-- DOMPurify: used to sanitize feed HTML before inserting into the page -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>

  <script>
    // Robust base href calculation: set base to feed's directory (include trailing slash)
    function setBaseHref(rssurl) {
      try {
        var baseEl = document.getElementsByTagName('base')[0];
        if (!baseEl) {
          baseEl = document.createElement('base');
          document.head.appendChild(baseEl);
        }
        var idx = rssurl.lastIndexOf('/');
        var baseHref = (idx >= 0) ? rssurl.substring(0, idx + 1) : rssurl;
        baseEl.href = baseHref;
      } catch (e) {
        console.warn('Could not set base href:', e);
      }
    }

    // Fetch text helper with optional CORS-proxy fallback (tries multiple proxies)
    const CORS_PROXIES = [
      'https://corsproxy.io/?url=',
      'https://api.allorigins.win/raw?url=',
      'https://thingproxy.freeboard.io/fetch/',   // some proxies accept raw URL
      'https://api.codetabs.cn/ajax?url='         // another commonly used public proxy
    ];

    // small helper to add a timeout to fetch
    function fetchWithTimeout(resource, options = {}, ms = 10000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), ms);
      const opt = Object.assign({}, options, { signal: controller.signal });
      return fetch(resource, opt).finally(() => clearTimeout(id));
    }

    async function fetchTextWithCorsFallback(url) {
      const errors = [];
      // 1) Try direct fetch first
      try {
        const resp = await fetchWithTimeout(url);
        if (!resp.ok) throw new Error('Network response was not ok: ' + resp.status);
        return await resp.text();
      } catch (err) {
        errors.push('direct:' + err.message);
        // continue to proxies
      }

      // 2) Try each proxy in order
      for (const proxy of CORS_PROXIES) {
        try {
          // Some proxies expect the raw url appended, others expect it encoded.
          // We'll encode unless the proxy string ends with '/fetch/' which commonly accepts raw.
          const proxyUrl = proxy.endsWith('/fetch/') ? (proxy + url) : (proxy + encodeURIComponent(url));
          const resp = await fetchWithTimeout(proxyUrl);
          if (!resp.ok) throw new Error('Proxy response was not ok: ' + resp.status + ' from ' + proxy);
          return await resp.text();
        } catch (err) {
          errors.push(`${proxy}:${err.message}`);
          // try next proxy
        }
      }

      // 3) All attempts failed
      throw new Error('Fetch failed (direct and all proxies): ' + errors.join(' | '));
    }

    // Helper to get inner-XML/HTML of a node in a robust way
    function getNodeInnerHtml(node) {
      if (!node) return '';
      // If innerHTML is present (browsers often provide it even for XML nodes)
      if ('innerHTML' in node && typeof node.innerHTML === 'string') {
        return node.innerHTML;
      }
      // Otherwise serialize child nodes
      var serializer = new XMLSerializer();
      var out = '';
      for (var i = 0; i < node.childNodes.length; i++) {
        out += serializer.serializeToString(node.childNodes[i]);
      }
      return out;
    }

    // Find a reasonable link for an entry/item: Atom's <link href="..."> (prefer rel="alternate"), or RSS <link>text</link>
    function findLink(node) {
      // Try Atom-style links first
      var links = node.getElementsByTagName('link');
      if (links && links.length) {
        // prefer link element with href attribute and rel=alternate (if present)
        for (var i = 0; i < links.length; i++) {
          var l = links[i];
          var rel = l.getAttribute ? l.getAttribute('rel') : null;
          var href = l.getAttribute ? l.getAttribute('href') : null;
          if (href && rel && rel.toLowerCase() === 'alternate') return href;
        }
        // otherwise any link with href
        for (var j = 0; j < links.length; j++) {
          var lj = links[j];
          var hrefj = lj.getAttribute ? lj.getAttribute('href') : null;
          if (hrefj) return hrefj;
        }
        // fallback to text content of first <link> (RSS)
        var firstLink = links[0];
        if (firstLink && firstLink.textContent) return firstLink.textContent.trim();
      }
      // If nothing found, try child <guid> or <id>
      var guid = node.getElementsByTagName('guid')[0];
      if (guid && guid.textContent) return guid.textContent.trim();
      var id = node.getElementsByTagName('id')[0];
      if (id && id.textContent) return id.textContent.trim();
      return null;
    }

    // Safe getter for tag text
    function getText(node, tag) {
      var el = node.getElementsByTagName(tag)[0];
      if (!el) return '';
      return el.textContent || '';
    }

    function setNodeLink(node, text, link) {
      if (link) {
          // set anchor attributes so it behaves like a normal external link
          node.textContent = text;
          node.setAttribute('href', link);
      } else {
          // no link found: replace anchor with a plain span to avoid a dead link
          var span = document.createElement('span');
          span.className = node.className;
          span.textContent = text;
          node.parentNode.replaceChild(span, node);
      }
    }

    // Main: fetch and render feed using template + DOMPurify for any HTML
    async function fetchAndRenderFeed(rssurl, options) {
      options = options || { allowHtml: true };
      var feedLinkEl = document.getElementById('feed-link');
      var feedInfoEl = document.getElementById('feed-info');
      var entriesContainer = document.getElementById('entries');
      var template = document.getElementById('entry-template');
      var templateMedia = document.getElementById('media-template');

      entriesContainer.innerHTML = '';
      feedInfoEl.textContent = 'Loadingâ€¦';

      try {
        setBaseHref(rssurl);
        var text = await fetchTextWithCorsFallback(rssurl);
        var doc = new DOMParser().parseFromString(text, 'application/xml');

        // Check for parse error
        if (doc.querySelector('parsererror')) {
          throw new Error('Failed to parse feed XML.');
        }

        // Feed-level title
        var feedTitle = (doc.getElementsByTagName('title')[0] && doc.getElementsByTagName('title')[0].textContent) || 'Feed';
        setNodeLink(feedLinkEl, feedTitle, findLink(doc));
        feedInfoEl.textContent = rssurl;

        // Choose entries: Atom <entry> or RSS <item>
        var atomEntries = Array.from(doc.getElementsByTagName('entry'));
        var rssItems = Array.from(doc.getElementsByTagName('item'));
        var nodes = atomEntries.length ? atomEntries : rssItems;

        if (!nodes.length) {
          entriesContainer.textContent = 'No entries found in feed.';
          return;
        }

        // Render each entry using the template
        nodes.forEach(function (node) {
          var clone = template.content.cloneNode(true);
          var linkEl = clone.querySelector('.entry-link');
          var dateEl = clone.querySelector('.entry-date');
          var contentEl = clone.querySelector('.entry-content');

          // Title
          var titleText = getText(node, 'title') || '(no title)';
          setNodeLink(linkEl, titleText, findLink(node));

          // Date parsing: try published/updated/pubDate
          var dateTags = ['published', 'updated', 'pubDate'];
          var dateText = '';
          for (var t = 0; t < dateTags.length; t++) {
            var dnode = node.getElementsByTagName(dateTags[t])[0];
            if (dnode && dnode.textContent) { dateText = dnode.textContent.trim(); break; }
          }
          if (dateText) {
            if (dateText[10] == " ") {
              dateText = dateText.replace("-", "/");
              dateText = dateText.replace("-", "/");
            }
            var d = new Date(dateText);
            dateEl.textContent = (isNaN(d.getTime()) ? dateText : d.toLocaleString());
            dateEl.setAttribute('datetime', dateText);
          } else {
            dateEl.textContent = '';
          }

          // Content: prefer <content> then <description> then summary
          var contentNode = node.getElementsByTagName('content')[0] || node.getElementsByTagName('description')[0] || node.getElementsByTagName('summary')[0];
          if (contentNode) {
            // try to extract HTML if present; otherwise textContent
            var contentRaw = getNodeInnerHtml(contentNode) || contentNode.textContent || '';

            if (contentRaw && options.allowHtml && window.DOMPurify) {
              contentEl.innerHTML = DOMPurify.sanitize(contentRaw);
              contentEl.innerHTML = contentEl.textContent || contentEl.innerText;
            } else {
              // Safe default: insert as text
              contentEl.textContent = contentRaw;
            }
          } else {
            var mediaImg = node.getElementsByTagName('media:thumbnail')[0];
            var mediaDescrption = node.getElementsByTagName('media:description')[0];
            var cloneMedia = templateMedia.content.cloneNode(true);
            var imgEl = cloneMedia.querySelector('.media-image');
            var descriptionEl = cloneMedia.querySelector('.media-content');

            if (mediaImg) {
                imgEl.setAttribute('src', mediaImg.getAttribute('url'));
                imgEl.setAttribute('width', mediaImg.getAttribute('width'));
                imgEl.setAttribute('height', mediaImg.getAttribute('height'));
            }

            if (mediaDescrption) {
              descriptionEl.textContent = mediaDescrption.textContent;
            }

            contentEl.appendChild(cloneMedia);
          }

          entriesContainer.appendChild(clone);
        });

      } catch (err) {
        entriesContainer.textContent = 'Error loading feed: ' + err.message;
        feedInfoEl.textContent = rssurl;
        console.error(err);
      }
    }

    // Prompt for URL and load
    (function init() {
      const urlParams = new URLSearchParams(window.location.search);
      var rssurl = urlParams.get('rss');
      if (!rssurl) {
        var defaultUrl = "https://github.com/RadAd.atom";
        rssurl = window.prompt("RSS Url:", defaultUrl);
      }
      if (!rssurl) {
        document.getElementById('entries').textContent = 'No RSS URL provided.';
        return;
      }
      // Optionally, ask whether to allow rendering HTML from feed (sanitized)
      var allowHtml = true;  //confirm('Render feed HTML (sanitized with DOMPurify)? OK = yes, Cancel = no (text only).');
      fetchAndRenderFeed(rssurl.trim(), { allowHtml: allowHtml });
    })();
  </script>
</body>
</html>
